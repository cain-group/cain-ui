const NAMESPACE="cain-ui",BUILD={allRenderFn:!0,appendChildSlotFix:!1,asyncLoading:!0,asyncQueue:!1,attachStyles:!0,cloneNodeFix:!1,cmpDidLoad:!1,cmpDidRender:!1,cmpDidUnload:!1,cmpDidUpdate:!1,cmpShouldUpdate:!1,cmpWillLoad:!1,cmpWillRender:!1,cmpWillUpdate:!1,connectedCallback:!1,constructableCSS:!1,cssAnnotations:!0,cssVarShim:!1,devTools:!0,disconnectedCallback:!1,dynamicImportShim:!1,element:!1,event:!1,hasRenderFn:!0,hostListener:!1,hostListenerTarget:!1,hostListenerTargetBody:!1,hostListenerTargetDocument:!1,hostListenerTargetParent:!1,hostListenerTargetWindow:!1,hotModuleReplacement:!0,hydrateClientSide:!1,hydrateServerSide:!1,hydratedAttribute:!1,hydratedClass:!0,initializeNextTick:!1,invisiblePrehydration:!0,isDebug:!1,isDev:!0,isTesting:!1,lazyLoad:!0,lifecycle:!1,lifecycleDOMEvents:!1,member:!0,method:!1,mode:!1,observeAttribute:!0,profile:!0,prop:!0,propBoolean:!0,propMutable:!1,propNumber:!0,propString:!0,reflect:!1,safari10:!1,scoped:!1,scopedSlotTextContentFix:!1,scriptDataOpts:!1,shadowDelegatesFocus:!1,shadowDom:!1,shadowDomShim:!1,slot:!0,slotChildNodesFix:!1,slotRelocation:!0,state:!0,style:!0,svg:!0,taskQueue:!0,transformTagName:!1,updatable:!0,vdomAttribute:!0,vdomClass:!0,vdomFunctional:!1,vdomKey:!1,vdomListener:!1,vdomPropOrAttr:!0,vdomRef:!1,vdomRender:!0,vdomStyle:!0,vdomText:!0,vdomXlink:!1,watchCallback:!1},Env={};let scopeId,contentRef,hostTagName,customError,i=0,useNativeShadowDom=!1,checkSlotFallbackVisibility=!1,checkSlotRelocate=!1,isSvgMode=!1,renderingRef=null,queueCongestion=0,queuePending=!1;const win="undefined"!==typeof window?window:{},CSS=BUILD.cssVarShim?win.CSS:null,doc=win.document||{head:{}},H=win.HTMLElement||class{},plt={$flags$:0,$resourcesUrl$:"",jmp:e=>e(),raf:e=>requestAnimationFrame(e),ael:(e,t,o,s)=>e.addEventListener(t,o,s),rel:(e,t,o,s)=>e.removeEventListener(t,o,s),ce:(e,t)=>new CustomEvent(e,t)},setPlatformHelpers=e=>{Object.assign(plt,e)},supportsShadow=!BUILD.shadowDomShim||!BUILD.shadowDom||(()=>(doc.head.attachShadow+"").indexOf("[native")>-1)(),supportsListenerOptions=(()=>{let e=!1;try{doc.addEventListener("e",null,Object.defineProperty({},"passive",{get(){e=!0}}))}catch(t){}return e})(),promiseResolve=e=>Promise.resolve(e),supportsConstructibleStylesheets=!!BUILD.constructableCSS&&(()=>{try{return new CSSStyleSheet,"function"===typeof(new CSSStyleSheet).replace}catch(e){}return!1})(),Context={},addHostEventListeners=(e,t,o,s)=>{BUILD.hostListener&&o&&(BUILD.hostListenerTargetParent&&(o=s?o.filter((([e])=>32&e)):o.filter((([e])=>!(32&e)))),o.map((([o,s,n])=>{const l=BUILD.hostListenerTarget?getHostListenerTarget(e,o):e,a=hostListenerProxy(t,n),r=hostListenerOpts(o);plt.ael(l,s,a,r),(t.$rmListeners$=t.$rmListeners$||[]).push((()=>plt.rel(l,s,a,r)))})))},hostListenerProxy=(e,t)=>o=>{try{BUILD.lazyLoad?256&e.$flags$?e.$lazyInstance$[t](o):(e.$queuedListeners$=e.$queuedListeners$||[]).push([t,o]):e.$hostElement$[t](o)}catch(s){consoleError(s)}},getHostListenerTarget=(e,t)=>BUILD.hostListenerTargetDocument&&4&t?doc:BUILD.hostListenerTargetWindow&&8&t?win:BUILD.hostListenerTargetBody&&16&t?doc.body:BUILD.hostListenerTargetParent&&32&t?e.parentElement:e,hostListenerOpts=e=>supportsListenerOptions?{passive:0!==(1&e),capture:0!==(2&e)}:0!==(2&e),CONTENT_REF_ID="r",ORG_LOCATION_ID="o",SLOT_NODE_ID="s",TEXT_NODE_ID="t",HYDRATE_ID="s-id",HYDRATED_STYLE_ID="sty-id",HYDRATE_CHILD_ID="c-id",HYDRATED_CSS="{visibility:hidden}.hydrated{visibility:inherit}",XLINK_NS="http://www.w3.org/1999/xlink",createTime=(e,t="")=>{if(BUILD.profile&&performance.mark){const o=`st:${e}:${t}:${i++}`;return performance.mark(o),()=>performance.measure(`[Stencil] ${e}() <${t}>`,o)}return()=>{}},uniqueTime=(e,t)=>BUILD.profile&&performance.mark?(0===performance.getEntriesByName(e).length&&performance.mark(e),()=>{0===performance.getEntriesByName(t).length&&performance.measure(t,e)}):()=>{},inspect=e=>{const t=getHostRef(e);if(!t)return;const o=t.$flags$,s=t.$hostElement$;return{renderCount:t.$renderCount$,flags:{hasRendered:!!(2&o),hasConnected:!!(1&o),isWaitingForChildren:!!(4&o),isConstructingInstance:!!(8&o),isQueuedForUpdate:!!(16&o),hasInitializedComponent:!!(32&o),hasLoadedComponent:!!(64&o),isWatchReady:!!(128&o),isListenReady:!!(256&o),needsRerender:!!(512&o)},instanceValues:t.$instanceValues$,ancestorComponent:t.$ancestorComponent$,hostElement:s,lazyInstance:t.$lazyInstance$,vnode:t.$vnode$,modeName:t.$modeName$,onReadyPromise:t.$onReadyPromise$,onReadyResolve:t.$onReadyResolve$,onInstancePromise:t.$onInstancePromise$,onInstanceResolve:t.$onInstanceResolve$,onRenderResolve:t.$onRenderResolve$,queuedListeners:t.$queuedListeners$,rmListeners:t.$rmListeners$,["s-id"]:s["s-id"],["s-cr"]:s["s-cr"],["s-lr"]:s["s-lr"],["s-p"]:s["s-p"],["s-rc"]:s["s-rc"],["s-sc"]:s["s-sc"]}},installDevTools=()=>{if(BUILD.devTools){const e=win.stencil=win.stencil||{},t=e.inspect;e.inspect=e=>{let o=inspect(e);return o||"function"!==typeof t||(o=t(e)),o}}},rootAppliedStyles=new WeakMap,registerStyle=(e,t,o)=>{let s=styles.get(e);supportsConstructibleStylesheets&&o?(s=s||new CSSStyleSheet,s.replace(t)):s=t,styles.set(e,s)},addStyle=(e,t,o,s)=>{let n=getScopeId(t,o),l=styles.get(n);if(!BUILD.attachStyles)return n;if(e=11===e.nodeType?e:doc,l)if("string"===typeof l){e=e.head||e;let o,a=rootAppliedStyles.get(e);if(a||rootAppliedStyles.set(e,a=new Set),!a.has(n)){if(BUILD.hydrateClientSide&&e.host&&(o=e.querySelector(`[${HYDRATED_STYLE_ID}="${n}"]`)))o.innerHTML=l;else{if(BUILD.cssVarShim&&plt.$cssShim$){o=plt.$cssShim$.createHostStyle(s,n,l,!!(10&t.$flags$));const e=o["s-sc"];e&&(n=e,a=null)}else o=doc.createElement("style"),o.innerHTML=l;(BUILD.hydrateServerSide||BUILD.hotModuleReplacement)&&o.setAttribute(HYDRATED_STYLE_ID,n),e.insertBefore(o,e.querySelector("link"))}a&&a.add(n)}}else BUILD.constructableCSS&&!e.adoptedStyleSheets.includes(l)&&(e.adoptedStyleSheets=[...e.adoptedStyleSheets,l]);return n},attachStyles=e=>{const t=e.$cmpMeta$,o=e.$hostElement$,s=t.$flags$,n=createTime("attachStyles",t.$tagName$),l=addStyle(BUILD.shadowDom&&supportsShadow&&o.shadowRoot?o.shadowRoot:o.getRootNode(),t,e.$modeName$,o);(BUILD.shadowDom||BUILD.scoped)&&BUILD.cssAnnotations&&10&s&&(o["s-sc"]=l,o.classList.add(l+"-h"),BUILD.scoped&&2&s&&o.classList.add(l+"-s")),n()},getScopeId=(e,t)=>"sc-"+(BUILD.mode&&t&&32&e.$flags$?e.$tagName$+"-"+t:e.$tagName$),convertScopedToShadow=e=>e.replace(/\/\*!@([^\/]+)\*\/[^\{]+\{/g,"$1{"),computeMode=e=>modeResolutionChain.map((t=>t(e))).find((e=>!!e)),setMode=e=>modeResolutionChain.push(e),getMode=e=>getHostRef(e).$modeName$,EMPTY_OBJ={},SVG_NS="http://www.w3.org/2000/svg",HTML_NS="http://www.w3.org/1999/xhtml",isDef=e=>null!=e,isComplexType=e=>(e=typeof e,"object"===e||"function"===e),h=(e,t,...o)=>{let s=null,n=null,l=null,a=!1,r=!1,i=[];const d=t=>{for(let o=0;o<t.length;o++)s=t[o],Array.isArray(s)?d(s):null!=s&&"boolean"!==typeof s&&((a="function"!==typeof e&&!isComplexType(s))?s=String(s):BUILD.isDev&&"function"!==typeof e&&void 0===s.$flags$&&consoleDevError("vNode passed as children has unexpected type.\nMake sure it's using the correct h() function.\nEmpty objects can also be the cause, look for JSX comments that became objects."),a&&r?i[i.length-1].$text$+=s:i.push(a?newVNode(null,s):s),r=a)};if(d(o),t&&(BUILD.isDev&&"input"===e&&validateInputProperties(t),BUILD.vdomKey&&t.key&&(n=t.key),BUILD.slotRelocation&&t.name&&(l=t.name),BUILD.vdomClass)){const e=t.className||t.class;e&&(t.class="object"!==typeof e?e:Object.keys(e).filter((t=>e[t])).join(" "))}if(BUILD.isDev&&i.some(isHost)&&consoleDevError("The <Host> must be the single root component. Make sure:\n- You are NOT using hostData() and <Host> in the same component.\n- <Host> is used once, and it's the single root component of the render() function."),BUILD.vdomFunctional&&"function"===typeof e)return e(null===t?{}:t,i,vdomFnUtils);const c=newVNode(e,null);return c.$attrs$=t,i.length>0&&(c.$children$=i),BUILD.vdomKey&&(c.$key$=n),BUILD.slotRelocation&&(c.$name$=l),c},newVNode=(e,t)=>{const o={$flags$:0,$tag$:e,$text$:t,$elm$:null,$children$:null};return BUILD.vdomAttribute&&(o.$attrs$=null),BUILD.vdomKey&&(o.$key$=null),BUILD.slotRelocation&&(o.$name$=null),o},Host={},isHost=e=>e&&e.$tag$===Host,vdomFnUtils={forEach:(e,t)=>e.map(convertToPublic).forEach(t),map:(e,t)=>e.map(convertToPublic).map(t).map(convertToPrivate)},convertToPublic=e=>({vattrs:e.$attrs$,vchildren:e.$children$,vkey:e.$key$,vname:e.$name$,vtag:e.$tag$,vtext:e.$text$}),convertToPrivate=e=>{if("function"===typeof e.vtag){const t=Object.assign({},e.vattrs);return e.vkey&&(t.key=e.vkey),e.vname&&(t.name=e.vname),h(e.vtag,t,...e.vchildren||[])}const t=newVNode(e.vtag,e.vtext);return t.$attrs$=e.vattrs,t.$children$=e.vchildren,t.$key$=e.vkey,t.$name$=e.vname,t},validateInputProperties=e=>{const t=Object.keys(e),o=t.indexOf("value");if(-1===o)return;const s=t.indexOf("type"),n=t.indexOf("min"),l=t.indexOf("max"),a=t.indexOf("step");(o<s||o<n||o<l||o<a)&&consoleDevWarn('The "value" prop of <input> should be set after "min", "max", "type" and "step"')},setAccessor=(e,t,o,s,n,l)=>{if(o!==s){let r=isMemberInElement(e,t),i=t.toLowerCase();if(BUILD.vdomClass&&"class"===t){const t=e.classList,n=parseClassList(o),l=parseClassList(s);t.remove(...n.filter((e=>e&&!l.includes(e)))),t.add(...l.filter((e=>e&&!n.includes(e))))}else if(BUILD.vdomStyle&&"style"===t){if(BUILD.updatable)for(const t in o)s&&null!=s[t]||(!BUILD.hydrateServerSide&&t.includes("-")?e.style.removeProperty(t):e.style[t]="");for(const t in s)o&&s[t]===o[t]||(!BUILD.hydrateServerSide&&t.includes("-")?e.style.setProperty(t,s[t]):e.style[t]=s[t])}else if(BUILD.vdomKey&&"key"===t);else if(BUILD.vdomRef&&"ref"===t)s&&s(e);else if(!BUILD.vdomListener||(BUILD.lazyLoad?r:e.__lookupSetter__(t))||"o"!==t[0]||"n"!==t[1]){if(BUILD.vdomPropOrAttr){const d=isComplexType(s);if((r||d&&null!==s)&&!n)try{if(e.tagName.includes("-"))e[t]=s;else{let n=null==s?"":s;"list"===t?r=!1:null!=o&&e[t]==n||(e[t]=n)}}catch(a){}let c=!1;BUILD.vdomXlink&&i!==(i=i.replace(/^xlink\:?/,""))&&(t=i,c=!0),null==s||!1===s?!1===s&&""!==e.getAttribute(t)||(BUILD.vdomXlink&&c?e.removeAttributeNS(XLINK_NS,t):e.removeAttribute(t)):(!r||4&l||n)&&!d&&(s=!0===s?"":s,BUILD.vdomXlink&&c?e.setAttributeNS(XLINK_NS,t,s):e.setAttribute(t,s))}}else t="-"===t[2]?t.slice(3):isMemberInElement(win,i)?i.slice(2):i[2]+t.slice(3),o&&plt.rel(e,t,o,!1),s&&plt.ael(e,t,s,!1)}},parseClassListRegex=/\s/,parseClassList=e=>e?e.split(parseClassListRegex):[],updateElement=(e,t,o,s)=>{const n=11===t.$elm$.nodeType&&t.$elm$.host?t.$elm$.host:t.$elm$,l=e&&e.$attrs$||EMPTY_OBJ,a=t.$attrs$||EMPTY_OBJ;if(BUILD.updatable)for(s in l)s in a||setAccessor(n,s,l[s],void 0,o,t.$flags$);for(s in a)setAccessor(n,s,l[s],a[s],o,t.$flags$)},createElm=(e,t,o,s)=>{let n,l,a,r=t.$children$[o],i=0;if(BUILD.slotRelocation&&!useNativeShadowDom&&(checkSlotRelocate=!0,"slot"===r.$tag$&&(scopeId&&s.classList.add(scopeId+"-s"),r.$flags$|=r.$children$?2:1)),BUILD.isDev&&r.$elm$&&consoleDevError(`The JSX ${null!==r.$text$?`"${r.$text$}" text`:`"${r.$tag$}" element`} node should not be shared within the same renderer. The renderer caches element lookups in order to improve performance. However, a side effect from this is that the exact same JSX node should not be reused. For more information please see https://stenciljs.com/docs/templating-jsx#avoid-shared-jsx-nodes`),BUILD.vdomText&&null!==r.$text$)n=r.$elm$=doc.createTextNode(r.$text$);else if(BUILD.slotRelocation&&1&r.$flags$)n=r.$elm$=BUILD.isDebug||BUILD.hydrateServerSide?slotReferenceDebugNode(r):doc.createTextNode("");else{if(BUILD.svg&&!isSvgMode&&(isSvgMode="svg"===r.$tag$),n=r.$elm$=BUILD.svg?doc.createElementNS(isSvgMode?SVG_NS:HTML_NS,BUILD.slotRelocation&&2&r.$flags$?"slot-fb":r.$tag$):doc.createElement(BUILD.slotRelocation&&2&r.$flags$?"slot-fb":r.$tag$),BUILD.svg&&isSvgMode&&"foreignObject"===r.$tag$&&(isSvgMode=!1),BUILD.vdomAttribute&&updateElement(null,r,isSvgMode),(BUILD.shadowDom||BUILD.scoped)&&isDef(scopeId)&&n["s-si"]!==scopeId&&n.classList.add(n["s-si"]=scopeId),r.$children$)for(i=0;i<r.$children$.length;++i)l=createElm(e,r,i,n),l&&n.appendChild(l);BUILD.svg&&("svg"===r.$tag$?isSvgMode=!1:"foreignObject"===n.tagName&&(isSvgMode=!0))}return BUILD.slotRelocation&&(n["s-hn"]=hostTagName,3&r.$flags$&&(n["s-sr"]=!0,n["s-cr"]=contentRef,n["s-sn"]=r.$name$||"",a=e&&e.$children$&&e.$children$[o],a&&a.$tag$===r.$tag$&&e.$elm$&&putBackInOriginalLocation(e.$elm$,!1))),n},putBackInOriginalLocation=(e,t)=>{plt.$flags$|=1;const o=e.childNodes;for(let s=o.length-1;s>=0;s--){const e=o[s];e["s-hn"]!==hostTagName&&e["s-ol"]&&(parentReferenceNode(e).insertBefore(e,referenceNode(e)),e["s-ol"].remove(),e["s-ol"]=void 0,checkSlotRelocate=!0),t&&putBackInOriginalLocation(e,t)}plt.$flags$&=-2},addVnodes=(e,t,o,s,n,l)=>{let a,r=BUILD.slotRelocation&&e["s-cr"]&&e["s-cr"].parentNode||e;for(BUILD.shadowDom&&r.shadowRoot&&r.tagName===hostTagName&&(r=r.shadowRoot);n<=l;++n)s[n]&&(a=createElm(null,o,n,e),a&&(s[n].$elm$=a,r.insertBefore(a,BUILD.slotRelocation?referenceNode(t):t)))},removeVnodes=(e,t,o,s,n)=>{for(;t<=o;++t)(s=e[t])&&(n=s.$elm$,callNodeRefs(s),BUILD.slotRelocation&&(checkSlotFallbackVisibility=!0,n["s-ol"]?n["s-ol"].remove():putBackInOriginalLocation(n,!0)),n.remove())},updateChildren=(e,t,o,s)=>{let n,l,a=0,r=0,i=0,d=0,c=t.length-1,$=t[0],m=t[c],p=s.length-1,h=s[0],u=s[p];while(a<=c&&r<=p)if(null==$)$=t[++a];else if(null==m)m=t[--c];else if(null==h)h=s[++r];else if(null==u)u=s[--p];else if(isSameVnode($,h))patch($,h),$=t[++a],h=s[++r];else if(isSameVnode(m,u))patch(m,u),m=t[--c],u=s[--p];else if(isSameVnode($,u))!BUILD.slotRelocation||"slot"!==$.$tag$&&"slot"!==u.$tag$||putBackInOriginalLocation($.$elm$.parentNode,!1),patch($,u),e.insertBefore($.$elm$,m.$elm$.nextSibling),$=t[++a],u=s[--p];else if(isSameVnode(m,h))!BUILD.slotRelocation||"slot"!==$.$tag$&&"slot"!==u.$tag$||putBackInOriginalLocation(m.$elm$.parentNode,!1),patch(m,h),e.insertBefore(m.$elm$,$.$elm$),m=t[--c],h=s[++r];else{if(i=-1,BUILD.vdomKey)for(d=a;d<=c;++d)if(t[d]&&null!==t[d].$key$&&t[d].$key$===h.$key$){i=d;break}BUILD.vdomKey&&i>=0?(l=t[i],l.$tag$!==h.$tag$?n=createElm(t&&t[r],o,i,e):(patch(l,h),t[i]=void 0,n=l.$elm$),h=s[++r]):(n=createElm(t&&t[r],o,r,e),h=s[++r]),n&&(BUILD.slotRelocation?parentReferenceNode($.$elm$).insertBefore(n,referenceNode($.$elm$)):$.$elm$.parentNode.insertBefore(n,$.$elm$))}a>c?addVnodes(e,null==s[p+1]?null:s[p+1].$elm$,o,s,r,p):BUILD.updatable&&r>p&&removeVnodes(t,a,c)},isSameVnode=(e,t)=>e.$tag$===t.$tag$&&(BUILD.slotRelocation&&"slot"===e.$tag$?e.$name$===t.$name$:!BUILD.vdomKey||e.$key$===t.$key$),referenceNode=e=>e&&e["s-ol"]||e,parentReferenceNode=e=>(e["s-ol"]?e["s-ol"]:e).parentNode,patch=(e,t)=>{const o=t.$elm$=e.$elm$,s=e.$children$,n=t.$children$,l=t.$tag$,a=t.$text$;let r;BUILD.vdomText&&null!==a?BUILD.vdomText&&BUILD.slotRelocation&&(r=o["s-cr"])?r.parentNode.textContent=a:BUILD.vdomText&&e.$text$!==a&&(o.data=a):(BUILD.svg&&(isSvgMode="svg"===l||"foreignObject"!==l&&isSvgMode),(BUILD.vdomAttribute||BUILD.reflect)&&(BUILD.slot&&"slot"===l||updateElement(e,t,isSvgMode)),BUILD.updatable&&null!==s&&null!==n?updateChildren(o,s,t,n):null!==n?(BUILD.updatable&&BUILD.vdomText&&null!==e.$text$&&(o.textContent=""),addVnodes(o,null,t,n,0,n.length-1)):BUILD.updatable&&null!==s&&removeVnodes(s,0,s.length-1),BUILD.svg&&isSvgMode&&"svg"===l&&(isSvgMode=!1))},updateFallbackSlotVisibility=e=>{let t,o,s,n,l,a,r=e.childNodes;for(o=0,s=r.length;o<s;o++)if(t=r[o],1===t.nodeType){if(t["s-sr"])for(l=t["s-sn"],t.hidden=!1,n=0;n<s;n++)if(a=r[n].nodeType,r[n]["s-hn"]!==t["s-hn"]||""!==l){if(1===a&&l===r[n].getAttribute("slot")){t.hidden=!0;break}}else if(1===a||3===a&&""!==r[n].textContent.trim()){t.hidden=!0;break}updateFallbackSlotVisibility(t)}},relocateNodes=[],relocateSlotContent=e=>{let t,o,s,n,l,a,r=0,i=e.childNodes,d=i.length;for(;r<d;r++){if(t=i[r],t["s-sr"]&&(o=t["s-cr"])&&o.parentNode)for(s=o.parentNode.childNodes,n=t["s-sn"],a=s.length-1;a>=0;a--)o=s[a],o["s-cn"]||o["s-nr"]||o["s-hn"]===t["s-hn"]||(isNodeLocatedInSlot(o,n)?(l=relocateNodes.find((e=>e.$nodeToRelocate$===o)),checkSlotFallbackVisibility=!0,o["s-sn"]=o["s-sn"]||n,l?l.$slotRefNode$=t:relocateNodes.push({$slotRefNode$:t,$nodeToRelocate$:o}),o["s-sr"]&&relocateNodes.map((e=>{isNodeLocatedInSlot(e.$nodeToRelocate$,o["s-sn"])&&(l=relocateNodes.find((e=>e.$nodeToRelocate$===o)),l&&!e.$slotRefNode$&&(e.$slotRefNode$=l.$slotRefNode$))}))):relocateNodes.some((e=>e.$nodeToRelocate$===o))||relocateNodes.push({$nodeToRelocate$:o}));1===t.nodeType&&relocateSlotContent(t)}},isNodeLocatedInSlot=(e,t)=>1===e.nodeType?null===e.getAttribute("slot")&&""===t||e.getAttribute("slot")===t:e["s-sn"]===t||""===t,callNodeRefs=e=>{BUILD.vdomRef&&(e.$attrs$&&e.$attrs$.ref&&e.$attrs$.ref(null),e.$children$&&e.$children$.map(callNodeRefs))},renderVdom=(e,t)=>{const o=e.$hostElement$,s=e.$cmpMeta$,n=e.$vnode$||newVNode(null,null),l=isHost(t)?t:h(null,null,t);if(hostTagName=o.tagName,BUILD.isDev&&Array.isArray(t)&&t.some(isHost))throw new Error(`The <Host> must be the single root component.\nLooks like the render() function of "${hostTagName.toLowerCase()}" is returning an array that contains the <Host>.\n\nThe render() function should look like this instead:\n\nrender() {\n  // Do not return an array\n  return (\n    <Host>{content}</Host>\n  );\n}\n  `);if(BUILD.reflect&&s.$attrsToReflect$&&(l.$attrs$=l.$attrs$||{},s.$attrsToReflect$.map((([e,t])=>l.$attrs$[t]=o[e]))),l.$tag$=null,l.$flags$|=4,e.$vnode$=l,l.$elm$=n.$elm$=BUILD.shadowDom&&o.shadowRoot||o,(BUILD.scoped||BUILD.shadowDom)&&(scopeId=o["s-sc"]),BUILD.slotRelocation&&(contentRef=o["s-cr"],useNativeShadowDom=supportsShadow&&0!==(1&s.$flags$),checkSlotFallbackVisibility=!1),patch(n,l),BUILD.slotRelocation){if(plt.$flags$|=1,checkSlotRelocate){let e,t,o,s,n,a;relocateSlotContent(l.$elm$);let r=0;for(;r<relocateNodes.length;r++)e=relocateNodes[r],t=e.$nodeToRelocate$,t["s-ol"]||(o=BUILD.isDebug||BUILD.hydrateServerSide?originalLocationDebugNode(t):doc.createTextNode(""),o["s-nr"]=t,t.parentNode.insertBefore(t["s-ol"]=o,t));for(r=0;r<relocateNodes.length;r++)if(e=relocateNodes[r],t=e.$nodeToRelocate$,e.$slotRefNode$){s=e.$slotRefNode$.parentNode,n=e.$slotRefNode$.nextSibling,o=t["s-ol"];while(o=o.previousSibling)if(a=o["s-nr"],a&&a["s-sn"]===t["s-sn"]&&s===a.parentNode&&(a=a.nextSibling,!a||!a["s-nr"])){n=a;break}(!n&&s!==t.parentNode||t.nextSibling!==n)&&t!==n&&(!t["s-hn"]&&t["s-ol"]&&(t["s-hn"]=t["s-ol"].parentNode.nodeName),s.insertBefore(t,n))}else 1===t.nodeType&&(t.hidden=!0)}checkSlotFallbackVisibility&&updateFallbackSlotVisibility(l.$elm$),plt.$flags$&=-2,relocateNodes.length=0}},slotReferenceDebugNode=e=>doc.createComment(`<slot${e.$name$?' name="'+e.$name$+'"':""}> (host=${hostTagName.toLowerCase()})`),originalLocationDebugNode=e=>doc.createComment("org-location for "+(e.localName?`<${e.localName}> (host=${e["s-hn"]})`:`[${e.textContent}]`)),getElement=e=>BUILD.lazyLoad?getHostRef(e).$hostElement$:e,createEvent=(e,t,o)=>{const s=getElement(e);return{emit:e=>(BUILD.isDev&&!s.isConnected&&consoleDevWarn(`The "${t}" event was emitted, but the dispatcher node is no longer connected to the dom.`),emitEvent(s,t,{bubbles:!!(4&o),composed:!!(2&o),cancelable:!!(1&o),detail:e}))}},emitEvent=(e,t,o)=>{const s=plt.ce(t,o);return e.dispatchEvent(s),s},attachToAncestor=(e,t)=>{BUILD.asyncLoading&&t&&!e.$onRenderResolve$&&t["s-p"]&&t["s-p"].push(new Promise((t=>e.$onRenderResolve$=t)))},scheduleUpdate=(e,t)=>{if(BUILD.taskQueue&&BUILD.updatable&&(e.$flags$|=16),BUILD.asyncLoading&&4&e.$flags$)return void(e.$flags$|=512);attachToAncestor(e,e.$ancestorComponent$);const o=()=>dispatchHooks(e,t);return BUILD.taskQueue?writeTask(o):o()},dispatchHooks=(e,t)=>{const o=e.$hostElement$,s=createTime("scheduleUpdate",e.$cmpMeta$.$tagName$),n=BUILD.lazyLoad?e.$lazyInstance$:o;let l;return t?(BUILD.lazyLoad&&BUILD.hostListener&&(e.$flags$|=256,e.$queuedListeners$&&(e.$queuedListeners$.map((([e,t])=>safeCall(n,e,t))),e.$queuedListeners$=null)),emitLifecycleEvent(o,"componentWillLoad"),BUILD.cmpWillLoad&&(l=safeCall(n,"componentWillLoad"))):(emitLifecycleEvent(o,"componentWillUpdate"),BUILD.cmpWillUpdate&&(l=safeCall(n,"componentWillUpdate"))),emitLifecycleEvent(o,"componentWillRender"),BUILD.cmpWillRender&&(l=then(l,(()=>safeCall(n,"componentWillRender")))),s(),then(l,(()=>updateComponent(e,n,t)))},updateComponent=async(e,t,o)=>{const s=e.$hostElement$,n=createTime("update",e.$cmpMeta$.$tagName$),l=s["s-rc"];BUILD.style&&o&&attachStyles(e);const a=createTime("render",e.$cmpMeta$.$tagName$);if(BUILD.isDev&&(e.$flags$|=1024),BUILD.hydrateServerSide?await callRender(e,t,s):callRender(e,t,s),BUILD.cssVarShim&&plt.$cssShim$&&plt.$cssShim$.updateHost(s),BUILD.isDev&&(e.$renderCount$++,e.$flags$&=-1025),BUILD.hydrateServerSide)try{serverSideConnected(s),o&&(1&e.$cmpMeta$.$flags$?s["s-en"]="":2&e.$cmpMeta$.$flags$&&(s["s-en"]="c"))}catch(r){consoleError(r,s)}if(BUILD.asyncLoading&&l&&(l.map((e=>e())),s["s-rc"]=void 0),a(),n(),BUILD.asyncLoading){const t=s["s-p"],o=()=>postUpdateComponent(e);0===t.length?o():(Promise.all(t).then(o),e.$flags$|=4,t.length=0)}else postUpdateComponent(e)},callRender=(e,t,o)=>{const s=!!BUILD.allRenderFn,n=!!BUILD.lazyLoad,l=!!BUILD.taskQueue,a=!!BUILD.updatable;try{if(renderingRef=t,t=(s||t.render)&&t.render(),a&&l&&(e.$flags$&=-17),(a||n)&&(e.$flags$|=2),BUILD.hasRenderFn||BUILD.reflect)if(BUILD.vdomRender||BUILD.reflect){if(BUILD.hydrateServerSide)return Promise.resolve(t).then((t=>renderVdom(e,t)));renderVdom(e,t)}else o.textContent=t}catch(r){consoleError(r,e.$hostElement$)}return renderingRef=null,null},getRenderingRef=()=>renderingRef,postUpdateComponent=e=>{const t=e.$cmpMeta$.$tagName$,o=e.$hostElement$,s=createTime("postUpdate",t),n=BUILD.lazyLoad?e.$lazyInstance$:o,l=e.$ancestorComponent$;BUILD.cmpDidRender&&(BUILD.isDev&&(e.$flags$|=1024),safeCall(n,"componentDidRender"),BUILD.isDev&&(e.$flags$&=-1025)),emitLifecycleEvent(o,"componentDidRender"),64&e.$flags$?(BUILD.cmpDidUpdate&&(BUILD.isDev&&(e.$flags$|=1024),safeCall(n,"componentDidUpdate"),BUILD.isDev&&(e.$flags$&=-1025)),emitLifecycleEvent(o,"componentDidUpdate"),s()):(e.$flags$|=64,BUILD.asyncLoading&&BUILD.cssAnnotations&&addHydratedFlag(o),BUILD.cmpDidLoad&&(BUILD.isDev&&(e.$flags$|=2048),safeCall(n,"componentDidLoad"),BUILD.isDev&&(e.$flags$&=-2049)),emitLifecycleEvent(o,"componentDidLoad"),s(),BUILD.asyncLoading&&(e.$onReadyResolve$(o),l||appDidLoad(t))),BUILD.hotModuleReplacement&&o["s-hmr-load"]&&o["s-hmr-load"](),BUILD.method&&BUILD.lazyLoad&&e.$onInstanceResolve$(o),BUILD.asyncLoading&&(e.$onRenderResolve$&&(e.$onRenderResolve$(),e.$onRenderResolve$=void 0),512&e.$flags$&&nextTick((()=>scheduleUpdate(e,!1))),e.$flags$&=-517)},forceUpdate=e=>{if(BUILD.updatable){const t=getHostRef(e),o=t.$hostElement$.isConnected;return o&&2===(18&t.$flags$)&&scheduleUpdate(t,!1),o}return!1},appDidLoad=e=>{BUILD.cssAnnotations&&addHydratedFlag(doc.documentElement),BUILD.asyncQueue&&(plt.$flags$|=2),nextTick((()=>emitEvent(win,"appload",{detail:{namespace:NAMESPACE}}))),BUILD.profile&&performance.measure&&performance.measure(`[Stencil] ${NAMESPACE} initial load (by ${e})`,"st:app:start")},safeCall=(e,t,o)=>{if(e&&e[t])try{return e[t](o)}catch(s){consoleError(s)}},then=(e,t)=>e&&e.then?e.then(t):t(),emitLifecycleEvent=(e,t)=>{BUILD.lifecycleDOMEvents&&emitEvent(e,"stencil_"+t,{bubbles:!0,composed:!0,detail:{namespace:NAMESPACE}})},addHydratedFlag=e=>BUILD.hydratedClass?e.classList.add("hydrated"):BUILD.hydratedAttribute?e.setAttribute("hydrated",""):void 0,serverSideConnected=e=>{const t=e.children;if(null!=t)for(let o=0,s=t.length;o<s;o++){const e=t[o];"function"===typeof e.connectedCallback&&e.connectedCallback(),serverSideConnected(e)}},initializeClientHydrate=(e,t,o,s)=>{const n=createTime("hydrateClient",t),l=e.shadowRoot,a=[],r=[],i=BUILD.shadowDom&&l?[]:null,d=s.$vnode$=newVNode(t,null);plt.$orgLocNodes$||initializeDocumentHydrate(doc.body,plt.$orgLocNodes$=new Map),e[HYDRATE_ID]=o,e.removeAttribute(HYDRATE_ID),clientHydrate(d,a,r,i,e,e,o),a.map((e=>{const o=e.$hostId$+"."+e.$nodeId$,s=plt.$orgLocNodes$.get(o),n=e.$elm$;s&&supportsShadow&&""===s["s-en"]&&s.parentNode.insertBefore(n,s.nextSibling),l||(n["s-hn"]=t,s&&(n["s-ol"]=s,n["s-ol"]["s-nr"]=n)),plt.$orgLocNodes$.delete(o)})),BUILD.shadowDom&&l&&i.map((e=>{e&&l.appendChild(e)})),n()},clientHydrate=(e,t,o,s,n,l,a)=>{let r,i,d,c;if(1===l.nodeType){for(r=l.getAttribute(HYDRATE_CHILD_ID),r&&(i=r.split("."),i[0]!==a&&"0"!==i[0]||(d={$flags$:0,$hostId$:i[0],$nodeId$:i[1],$depth$:i[2],$index$:i[3],$tag$:l.tagName.toLowerCase(),$elm$:l,$attrs$:null,$children$:null,$key$:null,$name$:null,$text$:null},t.push(d),l.removeAttribute(HYDRATE_CHILD_ID),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d,e=d,s&&"0"===d.$depth$&&(s[d.$index$]=d.$elm$))),c=l.childNodes.length-1;c>=0;c--)clientHydrate(e,t,o,s,n,l.childNodes[c],a);if(l.shadowRoot)for(c=l.shadowRoot.childNodes.length-1;c>=0;c--)clientHydrate(e,t,o,s,n,l.shadowRoot.childNodes[c],a)}else if(8===l.nodeType)i=l.nodeValue.split("."),i[1]!==a&&"0"!==i[1]||(r=i[0],d={$flags$:0,$hostId$:i[1],$nodeId$:i[2],$depth$:i[3],$index$:i[4],$elm$:l,$attrs$:null,$children$:null,$key$:null,$name$:null,$tag$:null,$text$:null},r===TEXT_NODE_ID?(d.$elm$=l.nextSibling,d.$elm$&&3===d.$elm$.nodeType&&(d.$text$=d.$elm$.textContent,t.push(d),l.remove(),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d,s&&"0"===d.$depth$&&(s[d.$index$]=d.$elm$))):d.$hostId$===a&&(r===SLOT_NODE_ID?(d.$tag$="slot",i[5]?l["s-sn"]=d.$name$=i[5]:l["s-sn"]="",l["s-sr"]=!0,BUILD.shadowDom&&s&&(d.$elm$=doc.createElement(d.$tag$),d.$name$&&d.$elm$.setAttribute("name",d.$name$),l.parentNode.insertBefore(d.$elm$,l),l.remove(),"0"===d.$depth$&&(s[d.$index$]=d.$elm$)),o.push(d),e.$children$||(e.$children$=[]),e.$children$[d.$index$]=d):r===CONTENT_REF_ID&&(BUILD.shadowDom&&s?l.remove():BUILD.slotRelocation&&(n["s-cr"]=l,l["s-cn"]=!0))));else if(e&&"style"===e.$tag$){const t=newVNode(null,l.textContent);t.$elm$=l,t.$index$="0",e.$children$=[t]}},initializeDocumentHydrate=(e,t)=>{if(1===e.nodeType){let o=0;for(;o<e.childNodes.length;o++)initializeDocumentHydrate(e.childNodes[o],t);if(e.shadowRoot)for(o=0;o<e.shadowRoot.childNodes.length;o++)initializeDocumentHydrate(e.shadowRoot.childNodes[o],t)}else if(8===e.nodeType){const o=e.nodeValue.split(".");o[0]===ORG_LOCATION_ID&&(t.set(o[1]+"."+o[2],e),e.nodeValue="",e["s-en"]=o[3])}},parsePropertyValue=(e,t)=>null==e||isComplexType(e)?e:BUILD.propBoolean&&4&t?"false"!==e&&(""===e||!!e):BUILD.propNumber&&2&t?parseFloat(e):BUILD.propString&&1&t?String(e):e,getValue=(e,t)=>getHostRef(e).$instanceValues$.get(t),setValue=(e,t,o,s)=>{const n=getHostRef(e),l=BUILD.lazyLoad?n.$hostElement$:e,a=n.$instanceValues$.get(t),r=n.$flags$,i=BUILD.lazyLoad?n.$lazyInstance$:l;o=parsePropertyValue(o,s.$members$[t][0]);const d=Number.isNaN(a)&&Number.isNaN(o),c=o!==a&&!d;if((!BUILD.lazyLoad||!(8&r)||void 0===a)&&c&&(n.$instanceValues$.set(t,o),BUILD.isDev&&(1024&n.$flags$?consoleDevWarn(`The state/prop "${t}" changed during rendering. This can potentially lead to infinite-loops and other bugs.`,"\nElement",l,"\nNew value",o,"\nOld value",a):2048&n.$flags$&&consoleDevWarn(`The state/prop "${t}" changed during "componentDidLoad()", this triggers extra re-renders, try to setup on "componentWillLoad()"`,"\nElement",l,"\nNew value",o,"\nOld value",a)),!BUILD.lazyLoad||i)){if(BUILD.watchCallback&&s.$watchers$&&128&r){const e=s.$watchers$[t];e&&e.map((e=>{try{i[e](o,a,t)}catch(s){consoleError(s,l)}}))}if(BUILD.updatable&&2===(18&r)){if(BUILD.cmpShouldUpdate&&i.componentShouldUpdate&&!1===i.componentShouldUpdate(o,a,t))return;scheduleUpdate(n,!1)}}},proxyComponent=(e,t,o)=>{if(BUILD.member&&t.$members$){BUILD.watchCallback&&e.watchers&&(t.$watchers$=e.watchers);const s=Object.entries(t.$members$),n=e.prototype;if(s.map((([e,[s]])=>{(BUILD.prop||BUILD.state)&&(31&s||(!BUILD.lazyLoad||2&o)&&32&s)?Object.defineProperty(n,e,{get(){return getValue(this,e)},set(n){if(BUILD.isDev){const n=getHostRef(this);0===(1&o)&&0===(8&n.$flags$)&&0!==(31&s)&&0===(1024&s)&&consoleDevWarn(`@Prop() "${e}" on <${t.$tagName$}> is immutable but was modified from within the component.\nMore information: https://stenciljs.com/docs/properties#prop-mutability`)}setValue(this,e,n,t)},configurable:!0,enumerable:!0}):BUILD.lazyLoad&&BUILD.method&&1&o&&64&s&&Object.defineProperty(n,e,{value(...t){const o=getHostRef(this);return o.$onInstancePromise$.then((()=>o.$lazyInstance$[e](...t)))}})})),BUILD.observeAttribute&&(!BUILD.lazyLoad||1&o)){const o=new Map;n.attributeChangedCallback=function(e,t,s){plt.jmp((()=>{const t=o.get(e);if(this.hasOwnProperty(t))s=this[t],delete this[t];else if(n.hasOwnProperty(t)&&"number"===typeof this[t]&&this[t]==s)return;this[t]=(null!==s||"boolean"!==typeof this[t])&&s}))},e.observedAttributes=s.filter((([e,t])=>15&t[0])).map((([e,s])=>{const n=s[1]||e;return o.set(n,e),BUILD.reflect&&512&s[0]&&t.$attrsToReflect$.push([e,n]),n}))}}return e},initializeComponent=async(e,t,o,s,n)=>{if((BUILD.lazyLoad||BUILD.hydrateServerSide||BUILD.style)&&0===(32&t.$flags$)){if(BUILD.lazyLoad||BUILD.hydrateClientSide){if(t.$flags$|=32,n=loadModule(o,t,s),n.then){const e=uniqueTime(`st:load:${o.$tagName$}:${t.$modeName$}`,`[Stencil] Load module for <${o.$tagName$}>`);n=await n,e()}if((BUILD.isDev||BUILD.isDebug)&&!n)throw new Error(`Constructor for "${o.$tagName$}#${t.$modeName$}" was not found`);BUILD.member&&!n.isProxied&&(BUILD.watchCallback&&(o.$watchers$=n.watchers),proxyComponent(n,o,2),n.isProxied=!0);const e=createTime("createInstance",o.$tagName$);BUILD.member&&(t.$flags$|=8);try{new n(t)}catch(r){consoleError(r)}BUILD.member&&(t.$flags$&=-9),BUILD.watchCallback&&(t.$flags$|=128),e(),fireConnectedCallback(t.$lazyInstance$)}else n=e.constructor,t.$flags$|=32,customElements.whenDefined(o.$tagName$).then((()=>t.$flags$|=128));if(BUILD.style&&n.style){let s=n.style;BUILD.mode&&"string"!==typeof s&&(s=s[t.$modeName$=computeMode(e)],BUILD.hydrateServerSide&&t.$modeName$&&e.setAttribute("s-mode",t.$modeName$));const l=getScopeId(o,t.$modeName$);if(!styles.has(l)){const e=createTime("registerStyles",o.$tagName$);!BUILD.hydrateServerSide&&BUILD.shadowDom&&BUILD.shadowDomShim&&8&o.$flags$&&(s=await import("./shadow-css-4d56fa31.js").then((e=>e.scopeCss(s,l,!1)))),registerStyle(l,s,!!(1&o.$flags$)),e()}}}const l=t.$ancestorComponent$,a=()=>scheduleUpdate(t,!0);BUILD.asyncLoading&&l&&l["s-rc"]?l["s-rc"].push(a):a()},fireConnectedCallback=e=>{BUILD.lazyLoad&&BUILD.connectedCallback&&safeCall(e,"connectedCallback")},connectedCallback=e=>{if(0===(1&plt.$flags$)){const t=getHostRef(e),o=t.$cmpMeta$,s=createTime("connectedCallback",o.$tagName$);if(BUILD.hostListenerTargetParent&&addHostEventListeners(e,t,o.$listeners$,!0),1&t.$flags$)addHostEventListeners(e,t,o.$listeners$,!1),fireConnectedCallback(t.$lazyInstance$);else{let s;if(t.$flags$|=1,BUILD.hydrateClientSide&&(s=e.getAttribute(HYDRATE_ID),s)){if(BUILD.shadowDom&&supportsShadow&&1&o.$flags$){const t=BUILD.mode?addStyle(e.shadowRoot,o,e.getAttribute("s-mode")):addStyle(e.shadowRoot,o);e.classList.remove(t+"-h",t+"-s")}initializeClientHydrate(e,o.$tagName$,s,t)}if(BUILD.slotRelocation&&!s&&(BUILD.hydrateServerSide||(BUILD.slot||BUILD.shadowDom)&&12&o.$flags$)&&setContentReference(e),BUILD.asyncLoading){let o=e;while(o=o.parentNode||o.host)if(BUILD.hydrateClientSide&&1===o.nodeType&&o.hasAttribute("s-id")&&o["s-p"]||o["s-p"]){attachToAncestor(t,t.$ancestorComponent$=o);break}}BUILD.prop&&!BUILD.hydrateServerSide&&o.$members$&&Object.entries(o.$members$).map((([t,[o]])=>{if(31&o&&e.hasOwnProperty(t)){const o=e[t];delete e[t],e[t]=o}})),BUILD.initializeNextTick?nextTick((()=>initializeComponent(e,t,o))):initializeComponent(e,t,o)}s()}},setContentReference=e=>{const t=e["s-cr"]=doc.createComment(BUILD.isDebug?`content-ref (host=${e.localName})`:"");t["s-cn"]=!0,e.insertBefore(t,e.firstChild)},disconnectedCallback=e=>{if(0===(1&plt.$flags$)){const t=getHostRef(e),o=BUILD.lazyLoad?t.$lazyInstance$:e;BUILD.hostListener&&t.$rmListeners$&&(t.$rmListeners$.map((e=>e())),t.$rmListeners$=void 0),BUILD.cssVarShim&&plt.$cssShim$&&plt.$cssShim$.removeHost(e),BUILD.lazyLoad&&BUILD.disconnectedCallback&&safeCall(o,"disconnectedCallback"),BUILD.cmpDidUnload&&safeCall(o,"componentDidUnload")}},defineCustomElement=(e,t)=>{customElements.define(t[1],proxyCustomElement(e,t))},proxyCustomElement=(e,t)=>{const o={$flags$:t[0],$tagName$:t[1]};BUILD.member&&(o.$members$=t[2]),BUILD.hostListener&&(o.$listeners$=t[3]),BUILD.watchCallback&&(o.$watchers$=e.$watchers$),BUILD.reflect&&(o.$attrsToReflect$=[]),BUILD.shadowDom&&!supportsShadow&&1&o.$flags$&&(o.$flags$|=8);const s=e.prototype.connectedCallback,n=e.prototype.disconnectedCallback;return Object.assign(e.prototype,{__registerHost(){registerHost(this,o)},connectedCallback(){connectedCallback(this),BUILD.connectedCallback&&s&&s.call(this)},disconnectedCallback(){disconnectedCallback(this),BUILD.disconnectedCallback&&n&&n.call(this)},__attachShadow(){supportsShadow?BUILD.shadowDelegatesFocus?this.attachShadow({mode:"open",delegatesFocus:!!(16&o.$flags$)}):this.attachShadow({mode:"open"}):this.shadowRoot=this}}),e.is=o.$tagName$,proxyComponent(e,o,3)},forceModeUpdate=e=>{if(BUILD.style&&BUILD.mode&&!BUILD.lazyLoad){const t=computeMode(e),o=getHostRef(e);if(o.$modeName$!==t){const s=o.$cmpMeta$,n=e["s-sc"],l=getScopeId(s,t),a=e.constructor.style[t],r=s.$flags$;a&&(styles.has(l)||registerStyle(l,a,!!(1&r)),o.$modeName$=t,e.classList.remove(n+"-h",n+"-s"),attachStyles(o),forceUpdate(e))}}},hmrStart=(e,t,o)=>{const s=getHostRef(e);s.$flags$=1,e["s-hmr-load"]=()=>{delete e["s-hmr-load"]},initializeComponent(e,s,t,o)},patchCloneNode=e=>{const t=e.cloneNode;e.cloneNode=function(e){const o=this,s=!!BUILD.shadowDom&&(o.shadowRoot&&supportsShadow),n=t.call(o,!!s&&e);if(BUILD.slot&&!s&&e){let e,t,s=0,l=["s-id","s-cr","s-lr","s-rc","s-sc","s-p","s-cn","s-sr","s-sn","s-hn","s-ol","s-nr","s-si"];for(;s<o.childNodes.length;s++)e=o.childNodes[s]["s-nr"],t=l.every((e=>!o.childNodes[s][e])),e&&(BUILD.appendChildSlotFix&&n.__appendChild?n.__appendChild(e.cloneNode(!0)):n.appendChild(e.cloneNode(!0))),t&&n.appendChild(o.childNodes[s].cloneNode(!0))}return n}},patchSlotAppendChild=e=>{e.__appendChild=e.appendChild,e.appendChild=function(e){const t=e["s-sn"]=getSlotName(e),o=getHostSlotNode(this.childNodes,t);if(o){const s=getHostSlotChildNodes(o,t),n=s[s.length-1];return n.parentNode.insertBefore(e,n.nextSibling)}return this.__appendChild(e)}},patchTextContent=(e,t)=>{if(BUILD.scoped&&2&t.$flags$){const t=Object.getOwnPropertyDescriptor(Node.prototype,"textContent");Object.defineProperty(e,"__textContent",t),Object.defineProperty(e,"textContent",{get(){var e;const t=getHostSlotNode(this.childNodes,"");return 3===(null===(e=null===t||void 0===t?void 0:t.nextSibling)||void 0===e?void 0:e.nodeType)?t.nextSibling.textContent:t?t.textContent:this.__textContent},set(e){var t;const o=getHostSlotNode(this.childNodes,"");if(3===(null===(t=null===o||void 0===o?void 0:o.nextSibling)||void 0===t?void 0:t.nodeType))o.nextSibling.textContent=e;else if(o)o.textContent=e;else{this.__textContent=e;const t=this["s-cr"];t&&this.insertBefore(t,this.firstChild)}}})}},patchChildSlotNodes=(e,t)=>{class o extends Array{item(e){return this[e]}}if(8&t.$flags$){const t=e.__lookupGetter__("childNodes");Object.defineProperty(e,"children",{get(){return this.childNodes.map((e=>1===e.nodeType))}}),Object.defineProperty(e,"childElementCount",{get(){return e.children.length}}),Object.defineProperty(e,"childNodes",{get(){const e=t.call(this);if(0===(1&plt.$flags$)&&2&getHostRef(this).$flags$){const t=new o;for(let o=0;o<e.length;o++){const s=e[o]["s-nr"];s&&t.push(s)}return t}return o.from(e)}})}},getSlotName=e=>e["s-sn"]||1===e.nodeType&&e.getAttribute("slot")||"",getHostSlotNode=(e,t)=>{let o,s=0;for(;s<e.length;s++){if(o=e[s],o["s-sr"]&&o["s-sn"]===t)return o;if(o=getHostSlotNode(o.childNodes,t),o)return o}return null},getHostSlotChildNodes=(e,t)=>{const o=[e];while((e=e.nextSibling)&&e["s-sn"]===t)o.push(e);return o},bootstrapLazy=(e,t={})=>{BUILD.profile&&performance.mark&&performance.mark("st:app:start"),installDevTools();const o=createTime("bootstrapLazy"),s=[],n=t.exclude||[],l=win.customElements,a=doc.head,r=a.querySelector("meta[charset]"),i=doc.createElement("style"),d=[],c=doc.querySelectorAll(`[${HYDRATED_STYLE_ID}]`);let $,m=!0,p=0;if(Object.assign(plt,t),plt.$resourcesUrl$=new URL(t.resourcesUrl||"./",doc.baseURI).href,BUILD.asyncQueue&&t.syncQueue&&(plt.$flags$|=4),BUILD.hydrateClientSide&&(plt.$flags$|=2),BUILD.hydrateClientSide&&BUILD.shadowDom)for(;p<c.length;p++)registerStyle(c[p].getAttribute(HYDRATED_STYLE_ID),convertScopedToShadow(c[p].innerHTML),!0);e.map((e=>{e[1].map((o=>{const a={$flags$:o[0],$tagName$:o[1],$members$:o[2],$listeners$:o[3]};BUILD.member&&(a.$members$=o[2]),BUILD.hostListener&&(a.$listeners$=o[3]),BUILD.reflect&&(a.$attrsToReflect$=[]),BUILD.watchCallback&&(a.$watchers$={}),BUILD.shadowDom&&!supportsShadow&&1&a.$flags$&&(a.$flags$|=8);const r=BUILD.transformTagName&&t.transformTagName?t.transformTagName(a.$tagName$):a.$tagName$,i=class extends HTMLElement{constructor(e){super(e),e=this,registerHost(e,a),BUILD.shadowDom&&1&a.$flags$&&(supportsShadow?BUILD.shadowDelegatesFocus?e.attachShadow({mode:"open",delegatesFocus:!!(16&a.$flags$)}):e.attachShadow({mode:"open"}):BUILD.hydrateServerSide||"shadowRoot"in e||(e.shadowRoot=e)),BUILD.slotChildNodesFix&&patchChildSlotNodes(e,a)}connectedCallback(){$&&(clearTimeout($),$=null),m?d.push(this):plt.jmp((()=>connectedCallback(this)))}disconnectedCallback(){plt.jmp((()=>disconnectedCallback(this)))}componentOnReady(){return getHostRef(this).$onReadyPromise$}};BUILD.cloneNodeFix&&patchCloneNode(i.prototype),BUILD.appendChildSlotFix&&patchSlotAppendChild(i.prototype),BUILD.hotModuleReplacement&&(i.prototype["s-hmr"]=function(e){hmrStart(this,a,e)}),BUILD.scopedSlotTextContentFix&&patchTextContent(i.prototype,a),a.$lazyBundleId$=e[0],n.includes(r)||l.get(r)||(s.push(r),l.define(r,proxyComponent(i,a,1)))}))})),BUILD.invisiblePrehydration&&(BUILD.hydratedClass||BUILD.hydratedAttribute)&&(i.innerHTML=s+HYDRATED_CSS,i.setAttribute("data-styles",""),a.insertBefore(i,r?r.nextSibling:a.firstChild)),m=!1,d.length?d.map((e=>e.connectedCallback())):BUILD.profile?plt.jmp((()=>$=setTimeout(appDidLoad,30,"timeout"))):plt.jmp((()=>$=setTimeout(appDidLoad,30))),o()},getAssetPath=e=>{const t=new URL(e,plt.$resourcesUrl$);return t.origin!==win.location.origin?t.href:t.pathname},setAssetPath=e=>plt.$resourcesUrl$=e,getConnect=(e,t)=>{const o=()=>{let e=doc.querySelector(t);return e||(e=doc.createElement(t),doc.body.appendChild(e)),"function"===typeof e.componentOnReady?e.componentOnReady():Promise.resolve(e)},s=(...e)=>o().then((t=>t.create(...e)));return{create:s,componentOnReady:o}},getContext=(e,t)=>t in Context?Context[t]:"window"===t?win:"document"===t?doc:"isServer"===t||"isPrerender"===t?!!BUILD.hydrateServerSide:"isClient"===t?!BUILD.hydrateServerSide:"resourcesUrl"===t||"publicPath"===t?getAssetPath("."):"queue"===t?{write:writeTask,read:readTask,tick:{then(e){return nextTick(e)}}}:void 0,insertVdomAnnotations=(e,t)=>{if(null!=e){const o={hostIds:0,rootLevelIds:0,staticComponents:new Set(t)},s=[];parseVNodeAnnotations(e,e.body,o,s),s.forEach((t=>{if(null!=t){const s=t["s-nr"];let n=s["s-host-id"],l=s["s-node-id"],a=`${n}.${l}`;if(null==n)if(n=0,o.rootLevelIds++,l=o.rootLevelIds,a=`${n}.${l}`,1===s.nodeType)s.setAttribute(HYDRATE_CHILD_ID,a);else if(3===s.nodeType){if(0===n){const e=s.nodeValue.trim();if(""===e)return void t.remove()}const o=e.createComment(a);o.nodeValue=`${TEXT_NODE_ID}.${a}`,s.parentNode.insertBefore(o,s)}let r=`${ORG_LOCATION_ID}.${a}`;const i=t.parentElement;i&&(""===i["s-en"]?r+=".":"c"===i["s-en"]&&(r+=".c")),t.nodeValue=r}}))}},parseVNodeAnnotations=(e,t,o,s)=>{null!=t&&(null!=t["s-nr"]&&s.push(t),1===t.nodeType&&t.childNodes.forEach((t=>{const n=getHostRef(t);if(null!=n&&!o.staticComponents.has(t.nodeName.toLowerCase())){const s={nodeIds:0};insertVNodeAnnotations(e,t,n.$vnode$,o,s)}parseVNodeAnnotations(e,t,o,s)})))},insertVNodeAnnotations=(e,t,o,s,n)=>{if(null!=o){const l=++s.hostIds;if(t.setAttribute(HYDRATE_ID,l),null!=t["s-cr"]&&(t["s-cr"].nodeValue=`${CONTENT_REF_ID}.${l}`),null!=o.$children$){const t=0;o.$children$.forEach(((o,s)=>{insertChildVNodeAnnotations(e,o,n,l,t,s)}))}if(t&&o&&o.$elm$&&!t.hasAttribute("c-id")){const e=t.parentElement;if(e&&e.childNodes){const s=Array.from(e.childNodes),n=s.find((e=>8===e.nodeType&&e["s-sr"]));if(n){const e=s.indexOf(t)-1;o.$elm$.setAttribute(HYDRATE_CHILD_ID,`${n["s-host-id"]}.${n["s-node-id"]}.0.${e}`)}}}}},insertChildVNodeAnnotations=(e,t,o,s,n,l)=>{const a=t.$elm$;if(null==a)return;const r=o.nodeIds++,i=`${s}.${r}.${n}.${l}`;if(a["s-host-id"]=s,a["s-node-id"]=r,1===a.nodeType)a.setAttribute(HYDRATE_CHILD_ID,i);else if(3===a.nodeType){const t=a.parentNode,o=t.nodeName;if("STYLE"!==o&&"SCRIPT"!==o){const o=`${TEXT_NODE_ID}.${i}`,s=e.createComment(o);t.insertBefore(s,a)}}else if(8===a.nodeType&&a["s-sr"]){const e=a["s-sn"]||"",t=`${SLOT_NODE_ID}.${i}.${e}`;a.nodeValue=t}if(null!=t.$children$){const l=n+1;t.$children$.forEach(((t,n)=>{insertChildVNodeAnnotations(e,t,o,s,l,n)}))}},setPlatformOptions=e=>Object.assign(plt,e),Fragment=(e,t)=>t,hostRefs=new WeakMap,getHostRef=e=>hostRefs.get(e),registerInstance=(e,t)=>hostRefs.set(t.$lazyInstance$=e,t),registerHost=(e,t)=>{const o={$flags$:0,$hostElement$:e,$cmpMeta$:t,$instanceValues$:new Map};return BUILD.isDev&&(o.$renderCount$=0),BUILD.method&&BUILD.lazyLoad&&(o.$onInstancePromise$=new Promise((e=>o.$onInstanceResolve$=e))),BUILD.asyncLoading&&(o.$onReadyPromise$=new Promise((e=>o.$onReadyResolve$=e)),e["s-p"]=[],e["s-rc"]=[]),addHostEventListeners(e,o,t.$listeners$,!1),hostRefs.set(e,o)},isMemberInElement=(e,t)=>t in e,consoleError=(e,t)=>(customError||console.error)(e,t),STENCIL_DEV_MODE=BUILD.isTesting?["STENCIL:"]:["%cstencil","color: white;background:#4c47ff;font-weight: bold; font-size:10px; padding:2px 6px; border-radius: 5px"],consoleDevError=(...e)=>console.error(...STENCIL_DEV_MODE,...e),consoleDevWarn=(...e)=>console.warn(...STENCIL_DEV_MODE,...e),consoleDevInfo=(...e)=>console.info(...STENCIL_DEV_MODE,...e),setErrorHandler=e=>customError=e,cmpModules=new Map,loadModule=(e,t,o)=>{const s=e.$tagName$.replace(/-/g,"_"),n=e.$lazyBundleId$;if(BUILD.isDev&&"string"!==typeof n)return void consoleDevError(`Trying to lazily load component <${e.$tagName$}> with style mode "${t.$modeName$}", but it does not exist.`);const l=!BUILD.hotModuleReplacement&&cmpModules.get(n);return l?l[s]:import(`./${n}.entry.js${BUILD.hotModuleReplacement&&o?"?s-hmr="+o:""}`).then((e=>(BUILD.hotModuleReplacement||cmpModules.set(n,e),e[s])),consoleError)},styles=new Map,modeResolutionChain=[],queueDomReads=[],queueDomWrites=[],queueDomWritesLow=[],queueTask=(e,t)=>o=>{e.push(o),queuePending||(queuePending=!0,t&&4&plt.$flags$?nextTick(flush):plt.raf(flush))},consume=e=>{for(let o=0;o<e.length;o++)try{e[o](performance.now())}catch(t){consoleError(t)}e.length=0},consumeTimeout=(e,t)=>{let o=0,s=0;while(o<e.length&&(s=performance.now())<t)try{e[o++](s)}catch(n){consoleError(n)}o===e.length?e.length=0:0!==o&&e.splice(0,o)},flush=()=>{if(BUILD.asyncQueue&&queueCongestion++,consume(queueDomReads),BUILD.asyncQueue){const e=2===(6&plt.$flags$)?performance.now()+14*Math.ceil(.1*queueCongestion):1/0;consumeTimeout(queueDomWrites,e),consumeTimeout(queueDomWritesLow,e),queueDomWrites.length>0&&(queueDomWritesLow.push(...queueDomWrites),queueDomWrites.length=0),(queuePending=queueDomReads.length+queueDomWrites.length+queueDomWritesLow.length>0)?plt.raf(flush):queueCongestion=0}else consume(queueDomWrites),(queuePending=queueDomReads.length>0)&&plt.raf(flush)},nextTick=e=>promiseResolve().then(e),readTask=queueTask(queueDomReads,!1),writeTask=queueTask(queueDomWrites,!0),Build={isDev:!!BUILD.isDev,isBrowser:!0,isServer:!1,isTesting:!!BUILD.isTesting};export{BUILD as B,CSS as C,H,NAMESPACE as N,promiseResolve as a,bootstrapLazy as b,consoleDevInfo as c,doc as d,Host as e,getElement as g,h,plt as p,registerInstance as r,win as w};